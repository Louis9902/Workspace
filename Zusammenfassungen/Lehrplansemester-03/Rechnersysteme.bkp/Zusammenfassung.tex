\documentclass
[
	8pt,		% font size
	ngerman,	% hyphenation and more
	a4paper,	% paper size
	landscape,	% orientation
	final		% document status (final/draft)
]{extarticle}

% adjust language %
\usepackage[ngerman]{babel}
% integration of speacial characters %
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
% adjust page layout %
\usepackage{titlesec}
\usepackage{fancyhdr}
% --------------------------- %
\usepackage{multicol}
\usepackage{multirow}
% --------------------------- %
\usepackage{setspace}
\usepackage{geometry}
\usepackage{adjustbox}
% adjust colors %
\usepackage{color}
% integration of mathematical symbols %
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
% integration of source code %
\usepackage{listings}
% adjust enumerations %
\usepackage{enumitem}
% adjust tables %
\usepackage{tabularx}
% integration of graphics %
\usepackage{graphicx}
% create graphics %
\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows}
% integration of seperate files %
\usepackage{standalone}

% ========== INFORMATION ========== %
\def\name{Louis Seubert}
\def\prefix{Zusammenfassung}
\def\lecture{Rechnersysteme}
\def\maxpages{6}

% ============== ADJUSTMENTS ============== %
% adjust graphics path %
\graphicspath
{
	{figures/}
}
% adjust page layout %
\geometry
{
	left=0.55cm,
	right=0.55cm,
	top=1.10cm,
	bottom=0.55cm,
	headsep=2mm
}
% adjust source code view %
\lstset
{
	basicstyle=\ttfamily\footnotesize,
	columns=fullflexible,
	numbers=left,						% where to put the line-numbers
	numberstyle=\tiny,  				% the style that is used for the line-numbers
	stepnumber=1,
	numbersep=5pt,						% how far the line-numbers are from the code
	showspaces=false,					% show spaces adding particular underscores
	showstringspaces=false,				% underline spaces within strings
	showtabs=false,						% show tabs within strings adding particular underscores
	frame=none,							% adds a frame around the code
	tabsize=2,							% sets default tabsize to 2 spaces
	captionpos=b,						% sets the caption-position to bottom
	breaklines=true,					% sets automatic line breaking
	breakatwhitespace=false,			% sets if automatic breaks should only happen at whitespace
	xleftmargin=10pt					% left margin to prevent number clipping
}

% make header and footer %
\pagestyle{fancy}
\fancyhead{} % clear header
\fancyhead[L]{\prefix\;\lecture}
\fancyhead[R]{\thepage\;--\;\maxpages}
\fancyhead[C]{\name}
\fancyfoot{} % clear footer

% configure document %
\setitemize{leftmargin=15pt}
\setenumerate{leftmargin=15pt}
\setlist{itemsep=1pt,parsep=1pt,noitemsep}

\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt}
\setlength{\topskip}{10pt}
% set column seperator %
\setlength{\columnseprule}{0.5pt}

% change style %
\titleformat*{\section}{\large\bfseries}
\titlespacing*{\section}{0pt}{4pt}{0pt}

\titleformat*{\subsection}{\normalsize\bfseries}
\titlespacing*{\subsection}{0pt}{4pt}{0pt}

\titleformat*{\subsubsection}{\normalsize\bfseries}
\titlespacing*{\subsubsection}{0pt}{4pt}{0pt}

\titleformat*{\paragraph}{\normalsize\bfseries}
\titlespacing{\paragraph}{0pt}{.5em}{.5em}

\titleformat*{\subparagraph}{\small\bfseries}
\titlespacing*{\subparagraph}{0pt}{.5em}{.5em}


\input{./files/Configuration.tex}
\input{./files/Hyphenation.tex}

\newcommand{\dropin}[2][]
{
	\begin{center}
		\input{#1}
		\ifthenelse{\equal{#2}{}}{}{\footnotesize#2}
	\end{center}
}

\begin{document}
\begin{multicols*}{4}
	\section{Einheiten, Größen}
	\subsection{Datenmengen}
	\begin{center}
		\input{./Documents/Charts/DataSizes.tex}
	\end{center}
	\subsection{Frquenz \(f\)}
	\[f = \cfrac{1}{T}\]
	\section{Leistungsbewertung}
	\begin{description}
		\item[MIPS] millions of instructions per second
		\item[FLOPS] floating point operations per second
	\end{description}
	\important MIPS-Vergleiche ergeben lediglich Sinn inerhalb der gleichen ISA
	(Instruction Set Architecture).
	\[\text{MIPS} = \cfrac{10^3}{\text{Instruktionszeit in ns}}\]
	\subsection{Amdahlsches Gesetz}
	Die Beschleunigung eines Systems wird berechnet durch ein vergleich der Zeit:
	\[\text{Beschleunigung} = \cfrac{\text{Zeit vor der Beschleunigung}}{\text{Zeit nach der Beschleunigung}}\]
	Damit kann man folgende Gesetzmäßigkeit aufstellen:
	\[S = \cfrac{1}{(1-p)+\cfrac{p}{s}}\]
	Aus diesem Zusammenhang kann man nun auch folgendes herleiten:
	\[\cfrac{T_{0}}{T_{S}} = \cfrac{1}{(1-p)+\cfrac{p}{s}}\]
	\begin{definitions}
		$\(S\)$ & (Gesamt-)Beschleunigung des Programmes \\
		$\(s\)$ & Beschleunigung des Pro­gramm­teils welches von der Verbesserung profitiert \\
		$\(p\)$ & Anteil der Zeit, in dem die Verbesserung benutzt wird \\
		$\(T_{0}\)$ & Zeit vor der Beschleunigung \\
		$\(T_{S}\)$ & Zeit nach der Beschleunigung
	\end{definitions}
	\section{Fehlertoleranz}
	\subsection{N-Modulare-Redundanz}
	Die Wahrscheinlichkeit eines fehlerfreien Funktionieren eines Systemes
	\(p_{s}\), mit \(m\) Komponenten, ist abhängig von der Verfügbarkeit der
	Einzelkomponenten \(p_{c}\) und der Verfügbarkeit des Voters \(p_{v}\). Für
	einen perfekten bzw. nicht vorkommenden Voter ist \(p_{v} = 1\). Die
	maximale Anzahl der ausfallenden Komponenten \(w\), wird falls nicht gegeben,
	durch \(w = \lceil \frac{m}{2} \rceil\) representiert.
	\[p_{s} = \sum_{i = 0}^{w} \left( \binom{m}{m - 1} \cdot p_{c}^{m - 1} \cdot (1 - p_{c}) \right) \cdot p_{v}\]
	\begin{description}
		\item[2MR]
		      Wahrscheinlichkeit des fehlerfreien Funktionierens eines 2MR
		      Systems:\par 2 Komponenten mit der Verfügbarkeit \(p_{c}\) und
		      einem Voter mit der Verfügbarkeit \(p_{v}\):
		      \[p_{s} = \left(2 p_{c} - p_{c}^{2} \right) \cdot p_{v}\]
		\item[3MR]
		      Wahrscheinlichkeit des fehlerfreien Funktionierens eines 3MR
		      Systems:\par 3 Komponenten mit der Verfügbarkeit \(p_{c}\) und
		      einem Voter mit der Verfügbarkeit \(p_{v}\):
		      \[p_{s} = \left(3 p_{c}^{2} - 2 p_{c}^{3} \right) \cdot p_{v}\]
		\item[4MR]
		      Wahrscheinlichkeit des fehlerfreien Funktionierens eines 4MR
		      Systems:\par 4 Komponenten mit der Verfügbarkeit \(p_{c}\) und
		      einem Voter mit der Verfügbarkeit \(p_{v}\):
		      \[p_{s} = \left(3 p_{c}^{4} - 8 p_{c}^{3} + 6 p_{c}^{2} \right) \cdot p_{v}\]
		\item[5MR]
		      Wahrscheinlichkeit des fehlerfreien Funktionierens eines 5MR
		      Systems:\par 5 Komponenten mit der Verfügbarkeit \(p_{c}\) und
		      einem Voter mit der Verfügbarkeit \(p_{v}\):
		      \[p_{s} = \left(6 p_{c}^{5} - 15 p_{c}^{4} + 10 p_{c}^{3} \right) \cdot p_{v}\]
	\end{description}
	\section{Paritätsprüfung}
	\subsection{Paritätsbit}
	Die Wahrscheinlichkeit das ein Wort der Länge \(n\) wirklich fehlerfrei ist,
	wird bereits urch die Fehlererkennung mittels eines Paritätsbits erhöht.
	Dabei ist die \emph{Wahrscheinlichkeit für ein} korrektes Bit \(p\), wobei
	gilt das \(0<p<1\) ist. Die Bitfolge mit der Länge \(n+1\) wird dann als
	korrekt angesehen wenn alle \(n+1\) oder \(n\) Bits korrekt sind.
	Die Wahrscheinlichkeit für das Wort mit der Länge \(n\) und einem
	Paritätsbit wird wiefolt berechnet:
	\begin{align*}
		P_{\text{parity}} & = p^{n+1}+\binom{n+1}{n}\cdot p^{n}\cdot\left(1-p\right)  \\
		                  & = p^{n+1}+\left(n+1\right)\cdot\left(p^{n}-p^{n+1}\right) \\
		                  & = \left(n+1\right)\cdot p^{n}-n\cdot p^{n + 1}
	\end{align*}
	Für ein Wort der Länge \(n\) ist die Wahrscheinlichkeit das es korrekt
	angesehen wird: \[P_{\text{no\_parity}} = p^{n}\]
	\section{Hamming-Code}
	\subsection{Anzahl der Prüf- und Datenbits}
	Für ein Wort der länge \(n\) mit \(m\) Datenbits benötigt man \(r\) Prüfbits
	um einen 1-Bit-Fehler pro Wort zu korrigiren.
	Daraus ergibt sich die allgemeine Ungleichung: \[2^{r} \geq m + r + 1\]
	Und für einen \emph{perfekten} Hamming-Code ergibt sich: \[2^{r} = m + r + 1\]
	Der \emph{perfekte} Hamming-Code besitzt die Wortlänge \(2^{r} - 1\).
	\subsection{Hamming-Abstand}
	Der Hamming-Abstand gibt die Anzahl der Bits zwischen zwei beliebige Wörtern
	aus dem Code.
	\example
	Die zwei Wörter \(\texttt{1100100100}_2\) und \(\texttt{1001100011}_2\)
	haben den Hamming-Abstand \(h = 5\).
	\subsubsection*{Hamming-Abstand eines Codes}
	Der Hamming-Abstand eines Codes ist die kleinstmögliche Anzahl an Bits, die
	man verändern muss um ein neues gültiges Wort aus dem vorliegenden Code zu
	bekommen.
	\example
	\begin{center}
		\begin{minipage}{.35\linewidth}
			\begin{align*}
				x = \texttt{00110} \\
				y = \texttt{00101} \\
				z = \texttt{01110}
			\end{align*}
		\end{minipage}
		\begin{minipage}{.35\linewidth}
			\begin{eqnarray*}
				h_{xy} &=& 2    \\
				h_{xz} &=& 1    \\
				h_{yz} &=& 3
			\end{eqnarray*}
		\end{minipage}
	\end{center} \par
	Da der kleinste Abstand 1 ist, ist der Hamming-Abstand des Codes ebenfalls 1.
	\subsection{Fehlererkennung}
	Um \(d\) Bitfehler zu erkennen, braucht man den Hamming-Abstand \(h\):
	\begin{eqnarray*}
		h &=& d + 1 \\
		d &=& h - 1
	\end{eqnarray*}
	\subsection{Fehlerkorrektur}
	Um \(d\) Bitfehler zu korrigiren, braucht man den Hamming-Abstand \(h\):
	\begin{eqnarray*}
		h &=& 2d + 1 \\
		d &=& \left\lfloor\cfrac{h - 1}{2}\right\rfloor
	\end{eqnarray*}
	\subsection{Bündelfehlerkorrektur}
	Um mehrere aufeinanderfolgende Bitfehler zu korrigiren ordnet man die \(k\)
	mit Hamming codierten Wörter der Länge \(n\) in einer \(k \cdot n\) Matrix
	an. \emph{Dabei ist zu beachten das nun zuerst die erste Spalte der Matrix
	übertragen bzw. gespeichert wird.}\par Somit kann man einen \textbf{maximal}
	einen Bündelfehler der Länge \(k\) Bits korrigiren, dabei ist bei \(k\)
	aufeinanderfolgenden fehlerhaften Bits maximal 1 Bit pro Wort fehlerhaft.
	\example
	\includefigure{./graphics/Hamming/Abbildung-1.tex}
	Die übertragenen Bits lauten:\par
	\texttt{0111000 0011111 1111111 1100001 0111111 0000000}\par
	\texttt{1011110 0100101 0011011 0000011 0100101}
	\subsection{Hamming-Algorithmus}
	\subsubsection*{Paritäts-Kontrollbits}
	Paritäts-Kontrollbits $p$ an Zweierpotenz Positionen
	\begin{itemize}
		\item Paritätsbit $p_{1}$ prüft 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21
		\item Paritätsbit $p_{2}$ prüft 2, 3, 6, 7, 10, 11, 14, 15, 18, 19
		\item Paritätsbit $p_{4}$ prüft 4, 5, 6, 7, 12, 13, 14, 15, 20, 21
		\item Paritätsbit $p_{8}$ prüft 8, 9, 10, 11, 12, 13, 14, 15
		\item Paritätsbit $p_{16}$ prüft 16, 17, 18, 19, 20, 21
	\end{itemize}
	\example
	\includefigure{./graphics/Hamming/Abbildung-2.tex}
	\subsection{Erweiterungen}
	\subsubsection*{SECDED}
	\textbf{S}ingle \textbf{E}rror \textbf{C}orrection \textbf{D}ouble \textbf{E}rror
	\textbf{D}etection füget ein weiteres Paritätsbit an der Position \texttt{0} welches
	die gesamten anderen Bits auf Parität überprüft. \par
	\begin{itemize}
		\item Hamming-Prüfbits \cmark \quad Extra-Prüfbit \cmark\par
		      $\longrightarrow$ fehlerfrei oder mehr als 2 Fehler
		\item Hamming-Prüfbits \xmark \quad Extra-Prüfbit \xmark\par
		      $\longrightarrow$ 1-Bitfehler, korrigirbar mit Hamming
		\item Hamming-Prüfbits \xmark \quad Extra-Prüfbit \cmark\par
		      $\longrightarrow$ 2-Bitfehler, nicht lokalisier- bzw. korrigirbar
	\end{itemize}

	%\input{./files/sections/02-Leistungsbewertung.tex}
	%\input{./files/sections/03-Fehlertoleranz.tex}
	%\input{./files/sections/04-Paritaetspruefung.tex}
	%\input{./files/sections/05-Hamming.tex}
	\input{./files/sections/06-IJVM.tex}
	\input{./files/sections/07-HDD.tex}
	\input{./files/sections/08-SSD.tex}
	\input{./files/sections/09-Caches.tex}
	\input{./files/sections/10-Sprungvorhersage.tex}
	\input{./files/sections/11-Cache-Kohaerenz.tex}
	\input{./files/sections/12-Multithreading.tex}
\end{multicols*}
\end{document}
